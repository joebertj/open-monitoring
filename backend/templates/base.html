<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}BetterGovPH Open Monitoring{% endblock %}</title>
    <link rel="stylesheet" href="/static/css/tailwind.css">
    <link rel="stylesheet" href="/static/css/style.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body class="bg-gray-50 font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
    <!-- Header -->
    <header class="visualizations-header">
        <div class="visualizations-container">
        <div class="visualizations-logo-section">
            <a href="https://bettergov.ph" class="visualizations-logo-link" target="_blank">
                <img src="/static/images/BetterGov_Horizontal-Black.svg" alt="BetterGovPH" class="visualizations-logo-img">
            </a>
                <a href="/" class="visualizations-site-name-link">
                    <span class="visualizations-site-name">Open Monitoring</span>
                </a>
            </div>
        <nav class="visualizations-nav-menu">
          <a href="/" class="nav-link{% if request.url.path == '/' %} active{% endif %}">Dashboard</a>
          <a href="/alerts" class="nav-link{% if '/alerts' in request.url.path %} active{% endif %}">Alerts</a>
        </nav>
        </div>
    </header>

    <!-- Main Content -->
    <main class="visualizations-main">
        <div class="visualizations-page-content">
            {% block content %}{% endblock %}
        </div>
    </main>

    <!-- Modals (outside main, at body level for proper overlay) -->
    {% block modals %}{% endblock %}

    <script>
        // Auto-refresh dashboard data every 30 seconds without full page reload
        setInterval(async function() {
            try {
                // Only refresh if we're on the dashboard page and no modal is open
                const timeseriesModal = document.getElementById('timeseries-modal');
                const dnsModal = document.getElementById('dns-modal');
                const agentModal = document.getElementById('agent-modal');
                const isTimeseriesModalHidden = !timeseriesModal || timeseriesModal.classList.contains('hidden');
                const isDnsModalHidden = !dnsModal || dnsModal.classList.contains('hidden');
                const isAgentModalHidden = !agentModal || agentModal.classList.contains('hidden');

                if (window.location.pathname === '/' && isTimeseriesModalHidden && isDnsModalHidden && isAgentModalHidden) {
                    const response = await fetch('/api/subdomains');
                    if (response.ok) {
                        const data = await response.json();
                        // Update subdomain stats without full page reload
                        updateDashboardData(data.subdomains);
                    }
                }
            } catch (error) {
                console.error('Auto-refresh failed:', error);
            }
        }, 30000);

        function updateDashboardData(subdomains) {
            // Update dashboard header stats
            const totalCount = document.getElementById('total-count');
            const upCount = document.getElementById('up-count');
            const downCount = document.getElementById('down-count');
            const flappingCount = document.getElementById('flapping-count');
            const unknownCount = document.getElementById('unknown-count');
            
            if (totalCount) {
                totalCount.textContent = subdomains.length;
            }
            
            if (upCount) {
                const upServices = subdomains.filter(s => s.status === 'UP').length;
                upCount.textContent = upServices;
            }
            
            if (downCount) {
                const downServices = subdomains.filter(s => s.status === 'DOWN').length;
                downCount.textContent = downServices;
            }
            
            if (flappingCount) {
                const flappingServices = subdomains.filter(s => s.status === 'FLAPPING').length;
                flappingCount.textContent = flappingServices;
            }
            
            if (unknownCount) {
                const unknownServices = subdomains.filter(s => s.status === 'UNKNOWN').length;
                unknownCount.textContent = unknownServices;
            }

            // Update each subdomain card with fresh data
            subdomains.forEach(subdomain => {
                const card = document.querySelector(`[onclick*="${subdomain.subdomain}"]`);
                if (card) {
                    // Update data-status attribute
                    card.setAttribute('data-status', subdomain.status);
                    
                    // Update status - find the status badge (has rounded classes)
                    const statusSpan = card.querySelector('.px-2.py-1.rounded-full');
                    if (statusSpan) {
                        let statusClass = 'px-2 py-1 rounded-full text-xs font-medium ';
                        if (subdomain.status === 'UP') {
                            statusClass += 'bg-green-100 text-green-800';
                        } else if (subdomain.status === 'DOWN') {
                            statusClass += 'bg-red-100 text-red-800';
                        } else if (subdomain.status === 'FLAPPING') {
                            statusClass += 'bg-yellow-100 text-yellow-800';
                        } else {
                            statusClass += 'bg-amber-100 text-amber-800';
                        }
                        statusSpan.className = statusClass;
                        statusSpan.textContent = subdomain.status;
                    }

                    // Update uptime
                    const uptimeElements = card.querySelectorAll('.font-medium');
                    if (uptimeElements.length >= 2) {
                        uptimeElements[1].textContent = `${subdomain.uptime_percentage.toFixed(1)}%`;
                    }

                    // Update response time
                    if (uptimeElements.length >= 3) {
                        uptimeElements[2].textContent = subdomain.response_time_ms 
                            ? `${Math.round(subdomain.response_time_ms)}ms` 
                            : 'N/A';
                    }

                    // Update last check time
                    if (uptimeElements.length >= 4 && subdomain.last_check) {
                        const date = new Date(subdomain.last_check);
                        // Add 8 hours for UTC+8 display
                        date.setHours(date.getHours() + 8);
                        uptimeElements[3].textContent = date.toLocaleTimeString('en-US', {
                            hour: '2-digit',
                            minute: '2-digit',
                            timeZone: 'UTC'
                        }) + ' UTC+8';
                    }
                }
            });
        }
    </script>
</body>
</html>
