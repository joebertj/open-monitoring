<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}BetterGovPH Open Monitoring{% endblock %}</title>
    <link rel="stylesheet" href="/static/css/tailwind.css">
    <link rel="stylesheet" href="/static/css/style.css">
</head>
<body class="bg-gray-50 font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
    <!-- Header -->
    <header class="visualizations-header">
        <div class="visualizations-container">
        <div class="visualizations-logo-section">
            <a href="https://bettergov.ph" class="visualizations-logo-link" target="_blank">
                <img src="/static/images/BetterGov_Horizontal-Black.svg" alt="BetterGovPH" class="visualizations-logo-img">
            </a>
                <a href="/" class="visualizations-site-name-link">
                    <span class="visualizations-site-name">Open Monitoring</span>
                </a>
            </div>
        <nav class="visualizations-nav-menu">
          <a href="/" class="nav-link{% if request.url.path == '/' %} active{% endif %}">Dashboard</a>
          <a href="/alerts" class="nav-link{% if '/alerts' in request.url.path %} active{% endif %}">Alerts</a>
        </nav>
        </div>
    </header>

    <!-- Main Content -->
    <main class="visualizations-main">
        <div class="visualizations-page-content">
            {% block content %}{% endblock %}
        </div>
    </main>

    <script>
        // Auto-refresh dashboard data every 30 seconds without full page reload
        setInterval(async function() {
            try {
                // Only refresh if we're on the dashboard page and no modal is open
                const timeseriesModal = document.getElementById('timeseries-modal');
                const dnsModal = document.getElementById('dns-modal');
                const isTimeseriesModalHidden = !timeseriesModal || timeseriesModal.classList.contains('hidden');
                const isDnsModalHidden = !dnsModal || dnsModal.classList.contains('hidden');

                if (window.location.pathname === '/' && isTimeseriesModalHidden && isDnsModalHidden) {

                    const response = await fetch('/api/subdomains');
                    if (response.ok) {
                        const data = await response.json();
                        // Update subdomain stats without full page reload
                        updateDashboardData(data.subdomains);
                    }
                }
            } catch (error) {
                console.error('Auto-refresh failed:', error);
            }
        }, 30000);

        function updateDashboardData(subdomains) {
            // Update each subdomain card with fresh data
            subdomains.forEach(subdomain => {
                const card = document.querySelector(`[onclick*="${subdomain.subdomain}"]`);
                if (card) {
                    // Update status - find the status badge (has rounded classes)
                    const statusSpan = card.querySelector('.px-2.py-1.rounded-full');
                    if (statusSpan) {
                        statusSpan.className = `px-2 py-1 rounded-full text-xs font-medium ${
                            subdomain.uptime_percentage > 0 ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
                        }`;
                        statusSpan.textContent = subdomain.uptime_percentage > 0 ? 'UP' : 'DOWN';
                    }

                    // Update uptime
                    const uptimeSpan = card.querySelector('[data-uptime]');
                    if (uptimeSpan) {
                        uptimeSpan.textContent = `${subdomain.uptime_percentage.toFixed(1)}%`;
                    }

                    // Update last check time - find the span that comes after "Last Check:"
                    const lastCheckLabels = card.querySelectorAll('span');
                    let lastCheckSpan = null;
                    for (let i = 0; i < lastCheckLabels.length; i++) {
                        if (lastCheckLabels[i].textContent.includes('Last Check:')) {
                            lastCheckSpan = lastCheckLabels[i].nextElementSibling;
                            break;
                        }
                    }
                    if (lastCheckSpan && subdomain.last_check) {
                        const date = new Date(subdomain.last_check);
                        // Add 8 hours for UTC+8 display
                        date.setHours(date.getHours() + 8);
                        lastCheckSpan.textContent = date.toLocaleTimeString('en-US', {
                            hour: '2-digit',
                            minute: '2-digit',
                            timeZone: 'UTC'
                        }) + ' UTC+8';
                    }
                }
            });
        }
    </script>
</body>
</html>
